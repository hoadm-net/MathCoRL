"""
Utility functions for Function Prototype Prompting.

This module contains helper functions for code execution, data loading, and evaluation.
"""

import json
import os
import re
import traceback
from pathlib import Path
from typing import Dict, List, Any, Tuple, Optional

from .functions import get_execution_namespace


def get_datasets_dir() -> str:
    """Get the datasets directory path."""
    current_dir = Path(__file__).parent.parent
    return os.path.join(current_dir, "datasets")


def load_svamp_dataset(split: str = "test") -> List[Dict]:
    """
    Load SVAMP dataset.
    
    Args:
        split: "train" or "test"
    
    Returns:
        List of problems
    """
    datasets_dir = get_datasets_dir()
    dataset_path = os.path.join(datasets_dir, "SVAMP", f"{split}.json")
    
    try:
        with open(dataset_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"Dataset file not found: {dataset_path}")


def clean_code(raw_code: str) -> str:
    """
    Clean code generated by LLM.
    
    Args:
        raw_code: Raw code from LLM
        
    Returns:
        Cleaned Python code
    """
    # Remove all markdown code blocks
    code = re.sub(r'```python.*?\n', '', raw_code, flags=re.DOTALL)
    code = re.sub(r'```.*?\n', '', code, flags=re.DOTALL)
    code = re.sub(r'```', '', code)
    
    # Split into lines and clean each line
    lines = code.split('\n')
    cleaned_lines = []
    
    for line in lines:
        line = line.strip()
        # Skip empty lines and comments
        if line and not line.startswith('#') and not line.startswith('//'):
            # Remove any remaining backticks
            line = line.replace('`', '')
            cleaned_lines.append(line)
    
    # Join cleaned lines
    code = '\n'.join(cleaned_lines)
    
    # Remove leading/trailing whitespace
    code = code.strip()
    
    # Ensure result assignment
    if 'result' not in code and cleaned_lines:
        # Find the last meaningful line and assign it to result
        for i in range(len(cleaned_lines) - 1, -1, -1):
            line = cleaned_lines[i].strip()
            if line and not line.startswith('#'):
                # Check if it's an assignment or expression
                if '=' in line and not line.startswith('result'):
                    # This is an assignment, add result assignment
                    var_name = line.split('=')[0].strip()
                    code += f'\nresult = {var_name}'
                elif not '=' in line:
                    # This is an expression, assign to result
                    code += f'\nresult = {line}'
                break
    
    return code


def execute_code(code: str) -> Tuple[Any, str]:
    """
    Execute Python code with mathematical functions.
    
    Args:
        code: Python code to execute
        
    Returns:
        Tuple of (result, error_message)
    """
    try:
        # Create execution namespace with mathematical functions
        namespace = get_execution_namespace()
        
        # Execute code
        exec(code, namespace, namespace)
        
        # Get result
        if 'result' in namespace:
            return namespace['result'], ""
        else:
            return None, "Variable 'result' not found in code"
            
    except Exception as e:
        error_msg = f"Error executing code: {str(e)}\n{traceback.format_exc()}"
        return None, error_msg


def evaluate_result(predicted: Any, ground_truth: float) -> bool:
    """
    Evaluate predicted result against ground truth.
    
    Args:
        predicted: Predicted result
        ground_truth: Correct answer
        
    Returns:
        True if correct, False if incorrect
    """
    try:
        # Convert to float for comparison
        pred_float = float(predicted)
        return abs(pred_float - ground_truth) < 1e-6
    except (ValueError, TypeError):
        return False 